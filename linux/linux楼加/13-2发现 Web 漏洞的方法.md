---
show: step
version: 1.0
enable_checker: true
---
# 发现 Web 漏洞的方法

## 1. 课程说明

本课程为动手实验教程，为了能说清楚实验中的一些操作会加入理论内容，也会精选最值得读的文章推荐给你，在动手实践的同时扎实理论基础。

学习过程中遇到的所有问题，都可随时在[实验楼问答](https://www.shiyanlou.com/questions)中提出，与老师和同学一起交流。

由于该实验环境的特殊性，为了避免滥用安全软件攻击实验楼网站或其他站点，环境中禁用了联网功能，并且无法保存实验环境。

## 2. 学习方法

实验楼的 Kali 系列课程包含五个训练营，本训练营主要讲述 Web 应用攻击方法。课程包含20个实验，每个实验都提供详细的步骤和截图。适用于有一定 Linux 系统基础，想快速上手 Kali 渗透测试的同学。

学习方法是多实践，多提问。启动实验后按照实验步骤逐步操作，同时理解每一步的详细内容，如果有任何疑问，随时在[实验楼问答](https://www.shiyanlou.com/questions/)中提问，实验楼团队和我都会及时回复大家的所有问题。

如果实验开始部分有推荐阅读的材料，请务必先阅读后再继续实验，理论知识是实践必要的基础。

## 3. 本节内容简介

本实验中我们进一步渗透测试的概念，了解整个渗透测试的流程。需要依次完成下面几项任务：

- 渗透测试的流程
  + 确定目标
  + 信息采集
  + 漏洞扫描
  + 漏洞验证
  + 权限维持
  + 文档记录

## 4. 推荐阅读

1. [host 具体用法](http://www.computerhope.com/unix/host.htm)
2. [dig 具体用法](http://www.computerhope.com/unix/dig.htm)
3. [nmap 官网手册](https://nmap.org/man/zh/)

## 5. 渗透测试的流程

Kali 中为我们集成了许多的工具，有扫描的，有攻击的，等等。对于网站的渗透测试亦或者攻击我们不可能盲目的去扫描、攻击他，这样只会花费大量的时间，但却徒劳无功。我们去渗透测试一个网站会经过这样的一些流程：

- 确定目标：首先你要有一个渗透测试的目标，或者是攻击的目标。
- 信息采集：通过各种信息搜集工具，如目标的域名、IP、端口、后台应用运行的平台等等了解，只有当对后台的应用框架有了一定的了解我们才能有针对性的使用某一方面的技术或者漏洞进行攻破。
- 漏洞扫描：在对目标应用的运行平台有了一定的了解之后，我们可以搜集相关组件的所存在的漏洞进行预判可能存在的漏洞，或者通过漏洞扫描工具来发现错在的漏洞。
- 漏洞验证：发现漏洞之后便是对漏洞的一个验证，简单来说就是进行对目标的攻击，攻击目标便是对漏洞的利用登入设备然后进行提权，这样便可“为所欲为”。
- 权限维持：在攻破系统之后，会在创建一个权限较高的隐藏用户亦或者放置后门程序，以便下一次的登陆，而不用再次去攻击。
- 文档记录：在每一次攻击之后建议都用文档记录下来，以后对知识的总结与积累。

### 5.1 确定目标

这部分便不用多说，确定目标便是选定好自己需要渗透或者攻击的站点，有个明确的对象，明确的方向。

### 5.2 信息采集

信息收集阶段可以说是在整个渗透测试或者攻击很重要的阶段，毕竟知己知彼才能百战百胜，否则从目标主机使用的平台到数据库的使用再到 web 应用开发的语言等等的种类多如繁星我们一个个的尝试，什么时候才是一个头。

而对于信息的收集我们主要从这样的几个方面来收集：

- 网站的域名相关信息
- 网站的服务器相关信息
- 网站的组件常见漏洞（如 Nginx、tomcat 等等，通过社会工程学与 Google Hacking 查找、猜测可能存在的一些问题和信息）

通过信息的采集我们对我们的目标网站有个大体的了解，有了这样的了解便指定了我们攻击的方向，减少了一些无谓的工作，同样也能够大大的提高我们渗透的成功性。

1.网站的域名相关信息（因为实验环境关闭的关系，这部分内容无法在实验环境中完成，同学可以在本地自己尝试）

对一个网站了解的第一手信息必定是它的域名，毕竟要确定一个目标定然是访问过目标网站，而访问网站的最简便方式就是通过域名了，而查看一个域名的注册与相关的信息最常用的工具便是 `whois`。

> whois（读作“Who is”，非缩写）是用来查询域名的IP以及所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）(此信息来自于百度百科)

通过 whois 工具我们可以看到相关域名的注册单位，使用的 DNS 服务器，创建的时间等等的相关信息，非常的详细。例如使用这样的命令:

```
whois baidu.com
```

通过这样的命令我们可以得到：

![whois-info.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528361228.png/wm)

信息非常的多，我们主要可以从中获取到 DNS 服务器的信息，以及域名注册人的联系方式等相关信息，这样的一些信息会在后续阶段发挥作用，但是现在的第三方域名注册机构大多都注意到隐私保护这一块，所以在注册信息部分看不到相关人员信息了。

当然若是觉得这样只是为了查看对方的 dns 信息太过麻烦，我们还可以通过 `host` 工具来直接查看 DNS 相关信息

```
host -t ns baidu.com
```

当然 host 工具也不仅仅是这么简单的功能而已，我们知道域名的记录有这样及个类别：

| Type  | describe        |
| ----- | --------------- |
| SOA   | 权威记录        |
| NS    | 域名服务器记录  |
| A     | IPv4 的对应记录 |
| MX    | 邮件交换记录    |
| PTR   | IP 地址反解析   |
| CNAME | 别名记录        |

可以看出之前的 host 命令中使用的 `ns` 参数，便是查找域名服务器记录，举一反三，我们同样可以查出其他类型域名的记录对应关系。

所以我们基本上可以通过 host 工具查出该域名下的大部分子域名以及这些子域名的对应关系。

![host-ns.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528475486.png/wm)

与 host 功能类似的功能的工具还有 `dig`、`dnsenum`、`dnsdict6`、`fierce`、`dmitry` 等等。

例如 dig 工具：

```
dig shiyanlou.com any
```

![dig-info.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528492916.png/wm)

这样的一些工具虽然功能很类似，但是他们的侧重点不同所以各有各的优势，只有能够达到我们的目的，能利用该工具搜集到我们需要的信息的便是好工具。

2.网站的服务器相关信息

通过端口扫描来判断使用的服务。

在上一步我们通过相关的工具了解到目标设备的相关域名与其对应的 IP 地址，接下来我们可以利用这些 IP 地址做端口扫描，大部分的服务使用的端口都不会相同，并且人们因为懒惰在大多数情况下不会修改其默认的端口号，所以可以从端口很容易的判断出其使用的相关组件。

例如这样一些常用的端口号：

| Port | Describe                      |
| ---- | ----------------------------- |
| 21   | FTP                           |
| 22   | SSH                           |
| 23   | Telnet                        |
| 80   | HTTP use Nginx or Apache 等等 |
| 443  | HTTPS                         |
| 3306 | Mysql                         |
| 3389 | RDP                           |
| 5432 | PostgreSQL                    |
| 5900 | VNC                           |
| 6379 | Redis                         |
| 8080 | Tomcat 等                     |

若是我们发现这样一些端口开放着，我们基本能够猜到目标主机大致使用的架构，各种服务的组件。而我们如何去查看目标主机开放了哪些端口呢？我们会用到一个特别强大的端口扫描工具 nmap。

nmap 是一款用于网络发现和安全审计的网络安全工具，是 Network Mapper 的简称。

Nmap 可以检测目标主机是否在线、端口开放情况、侦测运行的服务类型及版本信息、侦测操作系统与设备类型等信息。它是网络管理员必用的软件之一。

例如我们可以通过 nmap 对目标主机进行特征抓取（获得版本、端口的相关信息）、服务识别（相关的厂商）、操作系统的识别（使用的 Windows 还是 Linux）：

当然在此之前我们需要打开我们的虚拟机环境

```
##开启 kali 环境
sudo virsh start Kali

##开启 Metasploitable2
sudo virsh start Metasploitable2
```

> 虚拟机开启需要一定的时间

等待两台虚拟机完全启动之后我们可以使用这样的命令登陆上 Kali

```
##kali 中只有 root 用户，默认密码是 toor
ssh root@kali
```

成功登陆 kali 之后我们在该系统中使用这样的 nmap 命令去扫描我们准备好的靶机系统：

```
nmap -sn target
```

在攻击一个主机之前我们当然要看它是否处于活动状态，否则后面的一切都属于白忙活，这样的扫描称之为探索扫描，通过这个命令我们会得到这样的显示：

![nmap-sn-info.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528531640.png/wm)

`-sn` 参数通常被称作 ping 扫描，用于发现目标主机，探测其是否处于开机状态。其原理便是该命令会在局域网中广播 ARP 请求，若是响应了请求的话定是处于开机状态，而反之则处于关闭的状态。

有一些网络基础的同学会知道，在理论上我们将网络分为七层，而 nmap 在使用该参数的时候处于的层次是自适应，因为当你扫描的目标地址若是局域网内部的 IP 地址、同一子网的地址时此命令首先会在局域网中广播 ARP 请求，看目标主机是否为内网设备（若是学习过由浅入深学网络的同学就会了解 ARP 协议是一个二层协议，用于 IP 地址与 MAC 地址之间的解析），若是内网设备便会直接响应，自然便是处于二层的扫描，但若是一外网地址内网的广播自然不会有主机响应其请求，此时便会使用 ICMP 协议，而 ICMP 协议便是一个网络层的协议，我们通常使用的 ping 命令便是使用的 ICMP 协议。而正因为使用的是 ping 命令来探知对方是否开机所以在获得的信息中不会得到 MAC 地址。

我们可以在 shiyanlou 的 shell 中使用 `ifconfig eth0` 知道主机的内网地址：

![ifconfig-eth0.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528561303.png/wm)

然后在 kali 中使用同样的方法来扫描宿主机，会发现结果中并没有 MAC 地址：

```
#注意你的 IP 地址可和我的不同，请使用上个命令得到的结果
nmap -sn 10.105.222.73
```

![nmap-sn-info-icmp.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528588428.png/wm)

若是我们通过在 shiyanlou 的 shell 中挂起或者关闭我们的靶机系统，我们在使用同样的命令，它会提示说目标主机似乎处于关闭的状态，因为主机没有响应其 ARP 请求：

```
## 挂起靶机
sudo virsh suspend Metasploitable2
```

![suspend-meta.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528608420.png/wm)

然后再在 kali 中尝试查看其状态：

```
nmap -sn target
```

会得到这样的结果：

![nmap-sn-info-shutdown.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528631576.png/wm)

拥有类似功能的工具还有 netdiscover，arping，scapy。他们大多都是直接针对 ARP（scapy 较为强大，可以针对网络层，甚至是传输层的探测，但是使用起来也相对复杂一点），针对数据链路层发现主机的工具，这里便不在一一介绍，有兴趣的同学可以去了解一下。

当然也有可能目标主机的防范措施做的比较好，开启防火墙不响应 ICMP 的数据包，那么我们将针对网络的第四层传输层进行探测，大多数的系统对于 TCP 或者 UDP 的请求都会给予响应。例如一个网站定会开发 80 端口，所以我们可以使用这个命令：

```
nmap target -PA80 -sn
```

`-PA` 参数便是执行针对 TCP 的 ACK 数据包进行探测，有一定网络基础的同学知道（在由浅入深学网络课程中也有讲到），80 端口默认情况下是用于进行 HTTP 协议，而该协议是基于 TCP 协议来进行数据传输，TCP 这样的数据传输方式需要在服务端与客户端之间进行三次握手来建立连接，才能传输数据。在三次握手时就会发送 SYN 与 ACK 数据包来表示请求建立连接与同意进行连接。

> 三次握手是基于 TCP 协议的服务所必然经过的一个过程，由此建立双向的连接，从而达到可靠传输的目的，所为的三次握手便是客户端与服务端之间的三次交互：
- 客户端向服务端发送建立连接的请求数据包（SYN 数据包）；
- 服务端收到客户端的数据包，便会同意建立连接，发送确认数据包（ACK 数据包），同时发送服务端向客户端的连接请求数据包（SYN）；
- 客户端收到服务端的请求，便回复发送确认数据包（ACK 数据包）。

>这就是所谓的三次握手。

通过该命令我们可以得到这样的结果：

![nmap-sn-info-PA.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528655892.png/wm)

> **注意**：若是你得到的结果是 shutdown，与我的不同，那是因为我们刚刚将其挂起了，需要它恢复才行。`sudo virsh resume Metasploitable2`

当然我们也可以不费这么大的功夫确认其是否开机，因为我们可以直接扫描看是否有开放的端口便知，这样的扫描通常称之为端口扫描：

```
nmap -sS target
```

我们可以看到靶机中所有基于 TCP 协议开放的端口：

![nmap-sS-info.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528680894.png/wm)

当然若是你想查看 UDP 相关的开放端口，我们也可以使用 `-sU` 参数，但是对于 UDP 的端口扫描十分的缓慢，大约需要 10 分钟左右甚至更多的时间，在他定格的画面敲击回车可以看见其扫描的进度：

```
nmap target -sU
```

![nmap-sU-info.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528702145.png/wm)

因为 UDP 本身是无连接的协议，所以一个打开的 UDP 端口并不会给我们返回任何响应包，不过如果端口关闭，某些系统将返回`PORT_UNREACH` 信息。由此可以查探 UDP 的端口是否开放，因为是某些系统给予响应，所以这样的探测方式也有可能出错。这就是为什么 UDP 的扫描如此的慢，不像 TCP 开放的端口三次握手，很快就有响应数据包传回，就可以知道端口是否开放。

在确认其处于正常的开机状态、有开放的端口后，我们可查看其使用的操作系统是哪一种平台，毕竟 Linux 与 Windows 还有 Mac 的差异化还是蛮大的，当然若是服务器的话也就是 Linux 与 Windows 了。这样的探查通常称之为指纹识别，我们可以使用以下这个命令：

```
nmap -O target
```

我们会得到这样的一些信息：

![nmap-o-info.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528747206.png/wm)

其中 `-O` 参数的作用便是开启操作系统的检测，从图中我们可以看到 nmap 扫描除了目标主机当前能够检测到的所有开放的端口，并且在最后提供了目标主机操作系统的类型与版本的猜测。

在对于操作系统的确认与版本信息的确认之后我们便需要对目标主机的服务识别，我们通过的 `nmap -O` 可以看到它只是把相关的协议的一些版本信息显示出来，但是具体用的什么组件是有很多没有显示出来的，例如 80 端口上运行的 HTTP 协议，但是实现该协议的服务组件有很多，如 Apache、Nginx 等等这样的组件默认都是运行在 80 端口上，还有 Tomcat、Jetty 等等这样的 HTTP 实现的组件也是可以运行在 80 端口上，不同的组件出现的漏洞也是不同的，当然攻击的方式也是不同的。

所以服务的识别能帮助我们进一步的缩小攻击面，进一步的提高攻击的成功率，使得后面的工作更加的高效。

通过这样的一个命令，我们不仅仅能够识别所有开放的端口，以及相关端口运行的协议，我们还可以看到实现相关协议所使用的组件：

```
nmap -sV target
```

![nmap-sV-info.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528769300.png/wm)

在图中我们可以看到，每个端口上运行的组件我们都知道了，80 上运行的 Apache 不是 nginx，我们只需要查找 Apache 相关的漏洞，由此可以减少很多不必要的工作（例如去搜集其他组件的相关漏洞）。

若是你对获得的操作系统的信息并不满足我们可以使用 `-A` 参数来同时启用操作系统检测和版本检测:

```
nmap -A target
```

![nmap-A-info.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528785115.png/wm)

往上翻看我们可以发现这次得到信息量非常的大，不仅显示了开放出来的端口号，同时把对应端口使用的服务以及服务使用的软件本版信息一同显示出来，最后给予了更加详尽的操作系统版本的信息。使用 `-A` 参数与使用 `-sV` 参数都可以获得相关服务识别的信息，但是他们的侧重点不同，根据自己需要信息的重点来选择怎样的参数。

由此方法我们可以获得更加详尽的信息，我们甚至得到了运行软件的版本信息，这样可以再次缩小我们需要针对的范围，甚至可以查看漏洞库，使用攻击手段是针对某个版本出现的漏洞。

例如在 Linux kernel >= 2.6.22 ，并且在 2016 年 10 月 18 日打补丁之前的版本都会遭受到 Dirty COW 的漏洞影响，若是检测目标的操作系统的版本较为老旧，我们便可使用该漏洞来提权获得目标主机的掌控权了。

而 nmap 是如何做到这样一切的呢？在于 Nmap 最著名的功能之一：用 TCP/IP 协议栈 fingerprinting 进行远程操作系统探测。Nmap 发送一系列 TCP 和 UDP 报文到远程主机，检查响应中的每一个比特。 在进行一打测试如 TCP ISN 采样，TCP 选项支持和排序，IPID 采样，和初始窗口大小检查之后， Nmap 把结果和数据库 nmap-os-fingerprints 中超过 1500 个已知的操作系统的 fingerprints 进行比较，如果有匹配，就打印出操作系统的详细信息。 每个fingerprint 包括一个自由格式的关于 OS 的描述文本， 和一个分类信息，它提供供应商名称(如 Sun)，下面的操作系统(如 Solaris)，OS 版本(如 10)， 和设备类型(通用设备，路由器，switch，游戏控制台等)。（此段来自于[nmap 官网](https://nmap.org/man/zh/man-os-detection.html)）

有攻击的方法也有防范的措施，所以我们不仅需要识别服务、操作系统，我们还需要对防火墙进行识别，我们可以通过这样一个命令来查看对方在端口是否使用了防火墙来进行过滤：

```
nmap -sA target
```

![nmap-sA-info.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528800980.png/wm)

而如何做到的防火墙识别？最简单的方法便是通过 TCP 三次握手的不同数据包得到的不同响应来判断，是否被防火墙所过滤：

| SYN 请求数据包的响应                    | ACK 请求数据包的响应 | 结论                                                         |
| --------------------------------------- | -------------------- | ------------------------------------------------------------ |
| 响应 SYN + ACK 数据包（可以第二次握手） | 响应 RST 状态        | 没有状态的过滤，可以进、可以出                               |
| 响应 SYN + ACK 数据包（可以第二次握手） | ACK 数据包无响应     | 有防火墙进行状态过滤，并且是禁止出方向的响应，开放入方向的连接（ SYN 数据包收到，有响应，这是开放入，而 ACK 数据包有响应，所以无法出） |
| SYN 数据包没有响应（无法第一次握手）    | 响应 RST 状态        | 有防火墙进行状态过滤，并且是禁止入方向的连接请求，开放出方向的响应（ SYN 数据包目标收不到，所以没有响应，这是禁止入的请求状态，而 ACK 数据包有响应，所以可以出） |
| SYN 数据包没有响应（无法第一次握手）    | ACK 数据包无响应     | 没有防火墙的过滤                                             |

通过这样的方法从端口的状态中得出防火墙扫描的结论，端口的状态与类型有这样的一些情况：

| 端口状态 | 端口显示类型            | 说明                       |
| -------- | ----------------------- | -------------------------- |
| Blocked  | Closed port             | 端口处于关闭的状态         |
| Filtered | Filtered port           | 端口处于被防火墙过滤的状态 |
| Allowed  | Open port（unfiltered） | 端口处于开发的状态         |

在 nmap 中还有一个非常有用的参数：

| 参数        | 参数所代表的含义                                    |
| ----------- | --------------------------------------------------- |
| `nmap -T0 ` | 非常慢的扫描，用于IDS(入侵检测系统)逃避             |
| `nmap -T1`  | 缓慢的扫描，介于0和2之间的速度，同样可以躲开某些IDS |
| `nmap -T2`  | 降低扫描速度，通常不用                              |
| `nmap -T3`  | 默认扫描速度                                        |
| `nmap -T4`  | 可能会淹没目标，如果有防火墙很可能会触发            |
| `nmap -T5`  | 极速扫描，牺牲了准确度来换取速度                    |

nmap 非常的强大，还可以针对数据包的类型状态来扫描目标主机，还可以同时扫描多个 IP，更甚者可以扫描整个子网等等的高级用法，有兴趣的同学可以查看[nmap 官网](https://nmap.org/man/zh/)提供的手册来学习，

nmap 的强大我们见识到了，但是 nmap 有特别多的参数，用法也非常的繁多，相对来说较为的复杂，在 Kali 中我们还有一个非常强大的工具--Metasploit。

Metasploit 相对来说比 Nmap 来扫描更加的简单，他仅仅针对有限的服务，不会每个端口都去尝试，这样的方式使得在识别端口上运行的服务特别的高效，并且速度更快。

使用 Metasploit 来扫描的方法很简单，只需要简单的几个步骤，例如我们使用 Metasploit 来扫描 UDP 相关的端口：

首先通过以下命令进入其字符界面：

```
##进入 console 界面需要一定的时间，请耐心等候，或预习下面的内容
root@kali:~# msfconsole 
```

![msfconsole-start.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528821288.png/wm)

接着使用 use 命令来调用我们需要使用的模块：

```
msf > use auxiliary/scanner/discovery/udp_sweep 
```

![msfconsole-use.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528837310.png/wm)

然后使用 set 命令来设置使用该模块时需要设置的参数，再此之前还可以使用 `show options` 命令来有哪些参数可以设置，哪些参数必须要设置：

```
msf  auxiliary(udp_sweep) > show options
```

![msfconsole-show-option.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528857743.png/wm)

通过这命令我们可以看到一个表格，其中包含所有可以设置的参数，有参数的名字，有设置的值，有是否为必须设置的参数，最后还有相关参数的描述

其中必须要设置，但却没有值的参数是 `RHOSTS`，该参数设置的便是我们的目标主机的 IP 地址，可以是某一个 IP 也可以是某个 IP 地址段，使用 set 命令来设置：

```
msf  auxiliary(udp_sweep) > set RHOSTS 192.168.122.102

#若是想设置成 IP 地址段
msf  auxiliary(udp_sweep) > set RHOSTS 192.168.122.1-100
```

设置 `THREADS` 参数为执行命令的线程数，设置高一点可以帮助我们提高扫描的时间

![msfconsole-set](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528871534.png/wm)

最后使用 `run` 命令就可以自动执行模块了，执行之后便会直接把结果显示在下方，是不是很简单，只需要四个步骤，并且我们可以看到用不了多久结果便展示出来了，端口对应的服务，使用的 UDP 版本：

![msfconsole-run.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528892343.png/wm)

这样便比 nmap 的扫描来的高效许多。

同样 metasploit 也有防火墙识别的模块，同样也是基于 SYN/ACK 探测的响应，来判断端口上是否有被过滤：

同样的第一步也是进入其 console 界面，当然已经进入的可以跳过该步骤：

```
##进入 console 界面需要一定的时间，请耐心等候，或预习下面的内容
root@kali:~# msfconsole 
```

![msfconsole-start.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528821288.png/wm)

接着第二步便是选择使用的模块，当然若是当前使用了其他模块

- 先退出之前模块的使用，再使用指定的模块
- 直接使用其他模块

```
#第一种直接切换模块
msf auxiliary(udp_sweep) > use auxiliary/scanner/portscan/ack

#第二种退出以前模块的使用，使用新模块
msf auxiliary(udp_sweep) > back
msf > use auxiliary/scanner/portscan/ack
```

![msfconsole-change-use.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528926300.png/wm)

第三步便是查看参数与设置参数参数：

```
#查看参数
msf  auxiliary(ack) > show options

#设置参数

#设置扫描端口的范围,注意该模块会一个一个的去扫描
msf  auxiliary(ack) > set PORTS 1-1000

#设置目标主机
msf  auxiliary(ack) > set RHOSTS 192.168.122.102

#设置线程数
msf auxiliary(ack) > set THREADS 10

```

![msfconsole-change-set.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528939272.png/wm)

第四步便是执行命令开始扫描

```
msf auxiliary(ack) > run
```

![msfconsole-change-run.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528953068.png/wm)

3.网站的组件常见漏洞

在了解目标主机的开放端口之后我们大致能够猜出目标主机的服务框架了，当然还有如 HTTP 服务，无论是 Apache 还是 Nginx 都是提供该服务并且都是使用的 80 端口，遇到这样的情况我们可以通过查看其网站的 404 报错页面，亦或者是使用浏览器的开发者工具来查看其相关的包头，亦或者是通过抓包的方式来知晓其实用的平台。

在了解目标主机使用的平台之后我们只需要通过 google 亦或者是 baidu 等搜索引擎查看相关的应用、相对应的版本所存在的漏洞，这样的信息在后期去攻击、渗透的时候能给予我们很多的帮助与方向。

而带一定技巧的搜索方式不仅能提高效率，还能找到意想不到的信息，而这样的技巧通常被称之为 `Google Hacking`，这些技巧并没有多么的困难，只是利用搜索引擎使用的参数来查找资料而已。

> *注意*：所谓的 Google Hacking 并不是说只能使用 Google，只要是搜索引擎都可以使用，只是这名字是外国人起的，外国人更多的人使用 Google，我们当然也可以使用百度、搜狗、bing 等等其他的搜索引擎。

例如我们在搜索的关键字后面使用 `site:` 参数，可以限制只在某个站点搜索我输入的关键字：

```
如何学习渗透测试 site:www.zhihu.com
```

![![google-hacking-site.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528971066.png/wm)](http:///wm)

我们还可以使用 `OR` 参数，该参数表示只要匹配其前后两个词的任意一个都给出结果。

> **注意**：在搜索引擎中对内容并不却分大小写，但是此处的 OR 参数需要使用大写。

![google-hacking-or.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528986840.png/wm)

而与 `site:` 参数同类型的常有参数还有这样一些：

| 参数     | 说明                               |
| -------- | ---------------------------------- |
| intext   | 搜索文章的内容                     |
| intitle  | 搜索页面的标题                     |
| cache    | 搜索已经被删除但是留有缓存的页面   |
| related  | 搜索与之相关的网站                 |
| filetype | 搜索某种类型的文件，如 pdf、txt 等 |
| info     | 搜索某个网站的信息                 |
| inurl    | 匹配网站 url 中的关键字            |
| define   | 搜索某个词的定义                   |

例如使用 `related` 参数查看与 codecademy 类似的学习编程的网站：

```
related:www.codecademy.com
```

![google-hacking-related.png](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481528999248.png/wm)

这只是一些非常简单的用法，当然这个东西本身也并不是很难，但只要灵活的运用就会收到你所意想不到的信息，收集的好甚至能够得到别人后台数据库的登陆用户名、密码（如 phpadmin）。


### 5.3 漏洞扫描

通过 Google 或者 Baidu 等搜索引擎这样来查找漏洞非常的费时间，并且还可能让你一无所获，所以同样也出现了一些自动化的工具来帮我们检查目标站点所存在的漏洞。

对于漏洞检测最常用的工具便是 Nessus，它是安全漏洞自动收集工具，同时会提供一个非常漂亮的 web 页面来展示当前目标系统所存在的漏洞，但是由于环境的限制，我们并没有实验环境中安装该工具，有兴趣的同学可以自己搭建一个。

还有一个非常常用的工具便是 `joomscan`，全名为：Joomla Security Scanner。搜索已知的 Joomla 的安全漏洞来检测，并会生成一个文本格式或者 HTML 格式的检测报告，我们可以通过这样的命令来检测我们靶机存在的漏洞：

```
joomscan -u target
```

然后他会把检测到的结果展示出来：

![joomla-info](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481529024732.png/wm)

能把大部分可能被利用的 web 漏洞都展示出来，并做了相关的说明。

与之类似的工具还有 Nikto，Nikto 一个开源的 Perl 模块，它是通过识别潜在可疑的文件，对网页服务器进行全面的多种扫描：

![nikto-info](https://doc.shiyanlou.com/document-uid113508labid2397timestamp1481529035680.png/wm)

### 5.4 漏洞验证

扫描出目标主机存在的漏洞之后，便是对与漏洞的验证了，攻击的方式有很多种可以通过 Python 脚本，可以通过 msf 中存在的模块等等，通过对漏洞的攻击，从而获取到目标主机中的敏感信息，设置是登陆到目标主机中，到时候就想怎样就怎样了。

例如 FTP 的笑脸后门，只有通过前面信息收集发现其版本为 2.3.4，我们才会去验证笑脸后门，否则也是无用功。

> vsftpd v2.3.4 存在一个后门漏洞，这个后门以笑脸的形式拼接在用户名上，其代码绑定的监听端口是 6200，这样就可以通过 6200 ssh 登陆上去，虽然该问题迅速得到了开发人员的修复及删除，但是仍有不少人已经下载安装了该漏洞版本，从而保留了下来。（想要验证的同学可以参看这个讨论:<https://www.shiyanlou.com/questions/37109>）

### 5.5 权限维持

费了这么大的一番功夫，攻破系统，成功登陆上去，为了方便下一次登陆时的方便，我们需要留下后门（webshell 或者是其他的程序）。以防下一次需要重新攻击或者是管理员修复了漏洞之后我们无法登陆。

### 5.6 文档记录

通过文档的形式把整个攻击的过程都整理出来，方便开发人员讲解、查阅，同时也是对自己知识的一个总结。

## 6. 总结

本节实验中我们学习了以下内容，任何不清楚的地方欢迎到[实验楼问答](https://www.shiyanlou.com/questions)与我们交流：

- 渗透测试的流程
  + 确定目标
  + 信息采集
  + 漏洞扫描
  + 漏洞验证
  + 权限维持
  + 文档记录

重点在于信息采集与漏洞扫描。涉及到多种工具的使用，尤其是 Nmap 功能十分的强大，有兴趣的同学希望进一步学习。

请务必保证自己能够动手完成整个实验，只看文字很简单，真正操作的时候会遇到各种各样的问题，解决问题的过程才是收获的过程。

## 7.作业

1. 在本地中练习 whois 与 host 工具的使用，查看某个网站域名的相关信息；
2. 通过 Google Hacking 的用法查找 Kali 相关的 pdf 资料。